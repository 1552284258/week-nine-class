<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>

<body>

</body>

</html>
<script>
    /* 
        面向对象：
                    类                实例
                    人类              奥巴马
        
        JS中内置类：Array Sting Number Function Object RegExp Date ......
    
            字面量    var ary = []
            构造函数  var ary = new Array()
            //万物皆对象;
            自定义类 function A(){}  
            自定义类的实例只能通过 new 的方式创建
    
        JS中的常见设计模式
            单例模式  高级单例模式  工厂模式  构造函数模式   原型模式
    
     */

    //单例模式  命名空间
    var obj = {
        name: 'xxx',
        age: 22,
    };

    //高级单例模式  闭包，比普通单例模式多了隐私空间
    var obj2 = (function () {
        var name = 222;
        var age = 333;
        function f() {
            console.log(name,age);
        }
        function changeAge(n) {
            age = n;
        }
        return {
            name, age, f, changeAge
        }
    })()
    obj2.name = 666;
    obj2.changeAge(100)
    obj2.f(); // 222  100
    console.log(obj2.name, obj2.age); // 666  333

    //工厂模式 
    function factory(name, age) {
        var obj = {
            name, age,
            eat() { },
            play() { },
        }
        return obj
    }

    //构造函数模式    eslint(代码书写规范)
    function Person(name, age) {
        this.name = name;
        this.age = age;
        this.eat = function () {

        };
        this.paly = function () {

        };
    }
    var p1 = new Person('xxx',20)  //p1 是 Person 类的一个实例
    //new 执行时， 函数中的this就是当前创造的实例  默认返回的就是this；
    console.log(p1);

    class Men{  //es6中用class,class的东西只能通过new执行
        constructor(name,age){
            this.name = name;
            this.age = age;
        }
    }
    

    //原型模式   在构造函数模式的基础上，增加了一个原型(prototype)的概念; 原型其实就是一个堆内存
    function Women(name, age) {
        this.name = name;
        this.age = age;
    }
    Women.prototype.eat=function(){
        console.log('吃');
    }
    Women.prototype.play=function(){
        console.log('玩');
    }
    var w1 = new Women('sss',18);
    var w2 = new Women('aaa',19);
    w1.eat === w2.eat;  //实例 会通过 __proto__ 去访问所属类的原型；

    class Girl{
        constructor(name,age){
            this.name = name;
            this.age = age;
        }
        eat(){
            console.log('girl eat');
        }
        play(){
            console.log('girl eat');
        }
    }
    var g1 = new Girl('范耀辉',22)
    var g2 = new Girl('王园园',22)
    console.log(g2);
    

    //作用域链 是变量的查找机制；  
    //原型链： 是属性的查找机制；先在自己身上查找，没有的话 通过 __proto__ 再去所属类的原型上查找
    //        若所属类的原型上也没有该属性，则通过该原型的__proto__ 再去原型所属类的原型上接着查找，
    //        直到找到Object类(基类)的原型上，再没有的话，就是undefined；
</script>