<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>

<body>
    <input type="text" id="inp">
</body>

</html>
<script>
    let n = 0
    inp.oninput = function () {
        let s = this.value;
        if (s.length >= n) {
            n = s.length
            if (s.length == 3 || s.length == 8) {
                s += ' '
            }
            if (s.length > 13) {
                s = s.slice(0, 13)
                //验证手机号码
                // var reg = /^1[3-9]\d \d{4} \d{4}$/;
                // if(!s.test(reg)){
                //     alert('不合法')
                // }
            }
            this.value = s
        } else {
            n = s.length
        }
    }

</script>
<script>
    /* 正则
        var reg  = /\d/g
        var reg = new RegExp('\\d','g')

        匹配: test
        捕获: exec  捕获的贪婪性  在量词元字符后添加一个 ?; 懒惰像  加全局修饰符 g;

        \d  \D   \w  \W  .  [ab] [a-z] [^ab]  ^  $  18|19  () (?:)  (?=)  (?!)  \b边界
        +  ?  *  {n}  {n,m}  {n,}
        i ignoreCase
        m mutiline
        g global

        split(正则)
        match(正则)  正则没有g 结果和exec一样，正则有g会把字符串中所有符合大正则的部分都捕获到，但是不能捕获小分组
        replace(字符,字符)
        replace(正则,字符)
        replace(正则,回调函数)
        replace(正则,'$1')
    */

    
</script>